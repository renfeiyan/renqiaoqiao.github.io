<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="js,">










<meta name="description" content="js对象创建JS面向对象javaScript是一种基于对象(object-based)的语言；因JavaScript的语法中没有class(类)，因此它又不是一种真正的面向对象编程语言">
<meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="对象创建的6大方式">
<meta property="og:url" content="https://renqiaoqiao.xyz/2019/04/01/对象创建6大方式/index.html">
<meta property="og:site_name" content="study more">
<meta property="og:description" content="js对象创建JS面向对象javaScript是一种基于对象(object-based)的语言；因JavaScript的语法中没有class(类)，因此它又不是一种真正的面向对象编程语言">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4888929-d2e1166fb30c2681.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">
<meta property="og:updated_time" content="2019-08-18T12:06:43.868Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="对象创建的6大方式">
<meta name="twitter:description" content="js对象创建JS面向对象javaScript是一种基于对象(object-based)的语言；因JavaScript的语法中没有class(类)，因此它又不是一种真正的面向对象编程语言">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/4888929-d2e1166fb30c2681.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://renqiaoqiao.xyz/2019/04/01/对象创建6大方式/">





  <title>对象创建的6大方式 | study more</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">study more</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Study more</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renqiaoqiao.xyz/2019/04/01/对象创建6大方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="任巧巧">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study more">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">对象创建的6大方式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-01T12:36:18+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web前端/" itemprop="url" rel="index">
                    <span itemprop="name">web前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="js对象创建"><a href="#js对象创建" class="headerlink" title="js对象创建"></a>js对象创建</h3><p>JS面向对象<br>javaScript是一种基于对象(object-based)的语言；因JavaScript的语法中没有class(类)，因此它又不是一种真正的面向对象编程语言</p>
<a id="more"></a>
<h6 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h6><p>•    属性：对象下面的变量叫做对象的属性<br>•    方法：对象下面的函数叫做对象的方法</p>
<h4 id="1-Object实例"><a href="#1-Object实例" class="headerlink" title="1.Object实例"></a>1.Object实例</h4><p>使用Object函数或对象字面量都可以创建面向对象，但需要创建多个对象时，会产生大量的重复代码，可通过工厂方式来解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;liubei&quot;;</span><br><span class="line">person.age = 29;</span><br><span class="line">person.job = &quot;shayemuyou&quot;;</span><br><span class="line"></span><br><span class="line">person.sayName = function()&#123;</span><br><span class="line">    console.log(this.name); //Person.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来常用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;liubei&quot;,</span><br><span class="line">    age:29,</span><br><span class="line">    job:&quot;shayemuyou&quot;,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">       console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h4><p>该种方式在一个函数内创建好对象，然后把对象进行返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age, job)&#123;</span><br><span class="line">    var person = new Object();</span><br><span class="line">    person.name = name;</span><br><span class="line">    person.age = age;</span><br><span class="line">    person.job = job;</span><br><span class="line">    person.sayName = function()&#123;</span><br><span class="line">        console.log(this.name);  //即person.name</span><br><span class="line">        console.log(this.age);</span><br><span class="line">    &#125;</span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&quot;wei&quot;,25,&quot;software&quot;);</span><br><span class="line">var person2 = createPerson(&quot;bu&quot;,25,&quot;software&quot;);</span><br></pre></td></tr></table></figure>

<p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象。可以多次调用这个函数，每次都会返回一个包含三个属性一个方法的对象，==工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，即怎么样知道这是哪个对象类型。==</p>
<h4 id="3-构造函数模式（new-一个新对象）"><a href="#3-构造函数模式（new-一个新对象）" class="headerlink" title="3.构造函数模式（new 一个新对象）"></a>3.构造函数模式（new 一个新对象）</h4><p>使用自定义的构造函数，定义对象类型的属性和方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;wei&quot;,25,&quot;software&quot;);</span><br><span class="line">var person2 = new Person(&quot;bu&quot;,25,&quot;software&quot;);</span><br><span class="line">person1.sayName(); //wei</span><br><span class="line">person2.sayName(); //bu</span><br><span class="line"></span><br><span class="line">//用instanceof操作符，检测对象类型</span><br><span class="line">console.log(person1 instanceof Object);     //true</span><br><span class="line">console.log(person1 instanceof Person);     //true</span><br><span class="line">console.log(person2 instanceof Object);     //true</span><br><span class="line">console.log(person2 instanceof Person);     //true</span><br></pre></td></tr></table></figure>

<p>==构造函数模式与与工厂方式的区别：==</p>
<ul>
<li>没有显式的创建对象</li>
<li>直接将属性和方法赋给this对象</li>
<li>没有return语句</li>
</ul>
<p>==当一个函数被new 后，在JS中发生了一些事情：==</p>
<ol>
<li>创建了一个空对象</li>
<li>this指向这个空对象</li>
<li>执行函数中的语句</li>
<li>return 这个（新）空对象</li>
</ol>
<p>==person1和person2都有一个名为sayName()的方法，但是两个方法不是同一Function的实例。==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//验证</span><br><span class="line">console.log(person1.sayName == person2.sayName); //false</span><br></pre></td></tr></table></figure>

<h4 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.原型模式"></a>4.原型模式</h4><ol>
<li>尝试给构造函数添加方法</li>
<li>原型链<br>每一个构造函数都有一个属性叫做prototype，指向一个对象。当这个构造函数被new的时候，它的每一个实例的<strong>proto</strong>属性，也指向这个对象。</li>
<li>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例==共享==的属性和方法。使用原型对象的实例就是让所有实例共享它所包含的属性和方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">People--&gt;People.prototype</span><br><span class="line">People--&gt;xiaoming</span><br><span class="line">People.prototype--&gt;xiaoming</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们称People.prototype是People构造函数的“原型”，People.prototype是小明的“原型对象”。<br><strong>proto</strong>是神器，有原型链查找功能。当xiaoming身上没有某个属性的时候，系统会沿着<strong>proto</strong>去寻找它的原型对象身上有没有这个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &quot;wei&quot;;</span><br><span class="line">Person.prototype.age = 27;</span><br><span class="line">Person.prototype.job = &quot;Software&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();      //&quot;wei&quot;</span><br><span class="line"></span><br><span class="line">var person2 = new Person();</span><br><span class="line">person2.sayName();      //&quot;wei&quot;</span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName); //true</span><br><span class="line">//我们将sayName()方法和所有的属性直接添加在了Person的prototype属性中，构造函数变成了空函数。再 new 一个对象</span><br></pre></td></tr></table></figure>

<h4 id="5-组合使用构造函数模式和原型模式"><a href="#5-组合使用构造函数模式和原型模式" class="headerlink" title="5.组合使用构造函数模式和原型模式"></a>5.组合使用构造函数模式和原型模式</h4><p>构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123; </span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.friends = [&quot;乾隆&quot;,&quot;康熙&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;wei&quot;,29);</span><br><span class="line">var person2 = new Person(&quot;bu&quot;,25);</span><br><span class="line">person1.friends.push(&quot;嬴政&quot;);</span><br><span class="line">console.log(person1.friends);   //[&quot;乾隆&quot;, &quot;康熙&quot;, &quot;嬴政&quot;]</span><br><span class="line">console.log(person2.friends);   //[&quot;乾隆&quot;, &quot;康熙&quot;]</span><br><span class="line">console.log(person1.friends === person2.friends);   //false</span><br><span class="line">console.log(person1.sayName === person2.sayName);   //true</span><br></pre></td></tr></table></figure>

<p>实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。所以修改了person1.friends并不会改变person2.friends，因为他们分别引用了不同的数组。</p>
<h4 id="6-动态原型模式（不是很明白）"><a href="#6-动态原型模式（不是很明白）" class="headerlink" title="6.动态原型模式（不是很明白）"></a>6.动态原型模式（不是很明白）</h4><p>这里只在sayName()方法不存在的情况下才会将它添加到原型中。这断代码只有在第一次调用构造函数的时候才会被执行。此后，原型已经被初始化，不需要再做什么修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.friends = [&quot;乾隆&quot;,&quot;康熙&quot;];</span><br><span class="line">    //注意if语句</span><br><span class="line">    if(typeof this.sayName!=&quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName = function()&#123;</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;wei&quot;,29);</span><br><span class="line">person1.friends.push(&quot;嬴政&quot;);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure>

<p>注意：使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有的实例与新原型之间的联系。</p>
<h4 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h4><p>一个对象能够访问另一个对象的属性，同时这个对象还能添加自己的新的属性或是覆盖可访问的另一个对象的属性，这种方式叫继承</p>
<ol>
<li>每一个构造函数都有一个属性叫做原型(prototype) </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Person--&gt;Person.prototype</span><br><span class="line">Person--&gt;xiaoming(Person new 的一个对象)</span><br><span class="line">xiaoming--&gt;Person.prototype</span><br></pre></td></tr></table></figure>

<p>可以看出Person对象会自动获得prototyp属性，而prototype也是一个对象，会自动获得一个constructor属性，该属性正是指向Person对象。</p>
<p>当调用构造函数创建一个实例的时候，实例内部将包含一个内部指针（很多浏览器这个指针名字为<strong>proto</strong>）指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间。</p>
<ol start="2">
<li></li>
<li></li>
</ol>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>一个对象所拥有的属性不仅仅是它本身拥有的属性，它还会从其他对象中继承一些属性。当js在一个对象中找不到需要的属性时，它会到这个对象的父对象上去找，以此类推，这就构成了对象的原型链</p>
<p>//prototype(原型)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Foo(_name) &#123;</span><br><span class="line">  this.name = _name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.show = function() &#123;</span><br><span class="line">  console.log(&apos;I am &apos;, this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var f1 = new Foo(&apos;obj1&apos;);</span><br><span class="line">var f2 = new Foo(&apos;obj2&apos;);</span><br><span class="line"></span><br><span class="line">f1.show();  //  I am obj1</span><br><span class="line">f2.show(); //  I am obj2</span><br><span class="line"></span><br><span class="line">//将共同的方法放到Foo.prototype中，所有实例都共有这个方法</span><br></pre></td></tr></table></figure>

<p>过程如图所示<br><img src="https://upload-images.jianshu.io/upload_images/4888929-d2e1166fb30c2681.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p>
<ol>
<li><p>构造函数Foo()：里面的原型属性对象指向原型对象,<strong>proto</strong>属性指向构造函数的原型对象function.prototype</p>
</li>
<li><p>原型对象Foo.prorotype:原型对象中保存着实例共享方法，constructor指向构造函数，实现原型对象的所有方法都可以被访问，原型对象的<strong>proto</strong>指向构造函数的原型对象Object.prototype</p>
</li>
<li><p><strong>proto</strong>每个对象都有，js在new一个对象的时候，会将它的<strong>proto</strong>指向构造函数的prototype指向的那个对象。在上图中，f1、f2这些实例对象的<strong>4. proto</strong>都指向了Foo.prototype。<br>如果一个对象的<strong>proto</strong>指向了另一个对象，那么前者就继承了后者的所有属性。<br>==请注意<strong>proto</strong>与prototype的区别！<strong>proto</strong>才是真正连接原型链的东西，而prototype只是构造函数的一个指针属性而已。==</p>
<h6 id="buchong"><a href="#buchong" class="headerlink" title="buchong"></a>buchong</h6></li>
</ol>
<h4 id="Constructor："><a href="#Constructor：" class="headerlink" title="Constructor："></a>Constructor：</h4><ol>
<li>原型对象的属性constructor,该属性包含了一个指针，指向原构造函数,是用于创建和初始化类中创建一个对象的一种特殊方法</li>
<li>constructor在prototype中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)</span><br><span class="line">&#123; </span><br><span class="line">       	this.name = name; </span><br><span class="line">	this.age = age; </span><br><span class="line">&#125; </span><br><span class="line">Person.prototype.getName = function()&#123;              	console.log(this.name); </span><br><span class="line">&#125; </span><br><span class="line">Person.prototype.getAge = function()&#123; 	console.log(this.age); </span><br><span class="line">&#125; </span><br><span class="line">var obj = new Person(); alert(obj.constructor ==Person);// true</span><br></pre></td></tr></table></figure>

<p>重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)</span><br><span class="line">&#123; </span><br><span class="line">       	this.name = name; </span><br><span class="line">	this.age = age; </span><br><span class="line">&#125; </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">	constructor: Person, //强制指向Person 	getName: function()&#123; 	</span><br><span class="line">	console.log(this.name); &#125;, </span><br><span class="line">getAge: function()</span><br><span class="line">&#123; </span><br><span class="line">	console.log(this.age); </span><br><span class="line">&#125;                                                                 </span><br><span class="line">&#125;</span><br><span class="line">var obj = new Person(); </span><br><span class="line">Conole.log(obj.constructor ==Person);// true</span><br></pre></td></tr></table></figure>

<p>1.该方式重写了prototype,所以就将默认的constructor覆盖，这是constrcutor就指向Object(所有对象都继承自Object对象)<br>2.在使用constructor进行重新复制之后，constructor才会指向Person</p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ol>
<li>在一般函数方法中使用 this 指代全局对象</li>
<li>作为对象方法调用，this 指代上级对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">　　alert(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var o = &#123;&#125;;</span><br><span class="line">o.x = 1;</span><br><span class="line">o.m = test;</span><br><span class="line">o.m(); // 1</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>作为构造函数调用，this 指代new 出的对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = new test();</span><br><span class="line">　　alert(o.x); // 1</span><br><span class="line">//运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：</span><br><span class="line">　　var x = 2;</span><br><span class="line">　　function test()&#123;</span><br><span class="line">　　　　this.x = 1;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var o = new test();</span><br><span class="line">　　alert(x); //2</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>3.This只能在类的内部定义不能被类的外部定义,存在于函数之中，并且依赖函数执行上下文环境<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4></li>
<li>定义：<br>一个对象能够访问另一个对象的属性，同时这个对象还能添加自己的新的属性或是覆盖可访问的另一个对象的属性，这种方式叫继承<h5 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h5>将父类的实例作为子类的原型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Cat()&#123; </span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line">Cat.prototype.name = &apos;cat&apos;;</span><br><span class="line"></span><br><span class="line">//　Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.eat(&apos;fish&apos;));</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); //true </span><br><span class="line">console.log(cat instanceof Cat); //true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-直接继承prototype"><a href="#2-直接继承prototype" class="headerlink" title="2. 直接继承prototype"></a>2. 直接继承prototype</h5><h5 id="3-寄生式继承："><a href="#3-寄生式继承：" class="headerlink" title="3. 寄生式继承："></a>3. 寄生式继承：</h5><p>与原型式继承类似，基于某个对象或者某些信息创建对象，然后增强对象，最后返回对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line"> 　　function a()&#123;</span><br><span class="line"></span><br><span class="line"> 　　&#125;</span><br><span class="line">　　a.prototype=o;</span><br><span class="line">　　 return new a();</span><br><span class="line"> &#125;;</span><br><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = object(original); // 通过调用函数创建一个新对象</span><br><span class="line">    clone.sayHi = function()&#123; //以某种方式增强真个对象</span><br><span class="line">        console.log(&quot;hi&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone; //返回这个对象</span><br><span class="line">&#125;</span><br><span class="line">var person=&#123;</span><br><span class="line">            name:&quot;Nicholas&quot;,</span><br><span class="line">            friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]</span><br><span class="line">       &#125;</span><br><span class="line"> var obj = createAnother(person);</span><br><span class="line"> obj.sayHi(); // hi</span><br></pre></td></tr></table></figure>

<h5 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h5><p>在子类型构造函数数中调用超类型构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//  父类 </span><br><span class="line">        function Person(name,age)&#123; </span><br><span class="line">        	this.name = name; </span><br><span class="line">        	this.age = age; </span><br><span class="line">        &#125;</span><br><span class="line">        // 父类的原型对象属性 </span><br><span class="line">        Person.prototype.id = 10;</span><br><span class="line">        // 子类 ,继承了Person还传递了参数</span><br><span class="line">        function Boy(name,age,sex)&#123; </span><br><span class="line">        	//call apply 实现继承（新创建对象执行函数</span><br><span class="line">        	Person.call(this,name,age);</span><br><span class="line">        	this.sex = sex;</span><br><span class="line">        &#125;</span><br><span class="line">         var b = new Boy(&apos;c5&apos;,27,&apos;男&apos;); </span><br><span class="line">         console.log(b.name)// c5 </span><br><span class="line">         Console.log(b.sex);</span><br><span class="line">         console.log(b.id)//undinfind </span><br><span class="line">//父类的原型对象并没有继承</span><br></pre></td></tr></table></figure>

<h6 id="原型链-构造函数继承（组合继承-伪经典继承）-发挥二者之"><a href="#原型链-构造函数继承（组合继承-伪经典继承）-发挥二者之" class="headerlink" title="原型链+构造函数继承（组合继承/伪经典继承）:发挥二者之"></a>原型链+构造函数继承（组合继承/伪经典继承）:发挥二者之</h6><p>优点：<br>1.该种方式既继承了父类的模板，有继承了父类的原型对象<br>2.该种方法方便了子类传参<br>3.并且instanceof（判断对象是否为某一数据），isPrototypeOf(判断是否存在指定的实例中)也能够识别该种方式创建的对象</p>
<p>缺点：<br>构造函数有会重新实力一次，函数内部的比那辆也会重复一次</p>
<h5 id="5-Object-create-方法"><a href="#5-Object-create-方法" class="headerlink" title="5.Object.create()方法"></a>5.Object.create()方法</h5><p>这是ECMAScript5中新增的方法，这个方法用于创建一个新对象。被创建的对象继承另一个对象的原型，在创建新对象时可以指定一些属性。<br>==语法: Object.create(proto[,propertiesObject])== </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var x = &#123; </span><br><span class="line">    name: &apos;tom&apos;,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var y = Object.create(x, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        configurable: true,//可配置的</span><br><span class="line">        enumerable: true, //是否枚举</span><br><span class="line">        value: &apos;Tony&apos;,</span><br><span class="line">        writable: true //是否可以添加新对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">y.sayName() // &apos;Tony&apos;</span><br></pre></td></tr></table></figure>

<h5 id="Object-defineProperty的作用"><a href="#Object-defineProperty的作用" class="headerlink" title="Object.defineProperty的作用"></a>Object.defineProperty的作用</h5><ol>
<li>用来给对象新增属性，和修改对象中的属性</li>
<li>语法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br><span class="line"></span><br><span class="line">1 obj：必需。目标对象</span><br><span class="line">2 prop：必需。需定义或修改的属性的名字</span><br><span class="line">3 descriptor：必需。目标属性所拥有的特性</span><br></pre></td></tr></table></figure>

<ul>
<li><p>configurable<br>从字面意思看它表示“可配置”，含义是：当它为true时，该属性的描述符可被修改，并且该属性可被delete删除。同理，当它为false时，我们无法再次调用defineProperty去修改描述符，也不可通过delete删除。</p>
</li>
<li><p>enumerable<br>从字面意思看它表示“可枚举”，含义是：当它为true时，该属性可被迭代器枚举出来。比如使用for in或者是Object.keys。</p>
</li>
</ul>
<p>接下来就是数据描述符（data descriptor）了，有两个：</p>
<ul>
<li><p>value<br>这个就是该属性的值啦，即通过obj.key访问时返回。任何js数据类型都可以使用（number,string,object,function等）。</p>
</li>
<li><p>writable<br>这个也很好理解，表示该属性是否可写。当它为false时，属性不可被任何赋值语句重写。然而，此时还可以调用defineProperty来修改value，当然前提是configurable为true啦。</p>
</li>
</ul>
<h6 id="getter-and-setter"><a href="#getter-and-setter" class="headerlink" title="getter and setter"></a>getter and setter</h6><p>getter与setter其实是两个概念，并没有这样的属性。与之对应的是两个访问描述符（access descriptor）</p>
<ol>
<li><p>get<br>它是一个函数，访问该属性时会自动调用，函数的返回值即为该属性的value。默认为undefined。</p>
</li>
<li><p>set<br>它是一个函数，为该属性赋值时会自动调用，并且新值会被当做参数传入。</p>
<h4 id="es6-class"><a href="#es6-class" class="headerlink" title="es6 class"></a>es6 class</h4><p>定义类的方法的时候，前面不需要加function这个关键字,直接将函数定义放进去就行了 ，另外，方法之间不需要逗号分隔；<br>作者：startitunderground<br>链接：<a href="https://www.imooc.com/article/20596?block_id=tuijian_wz" target="_blank" rel="noopener">https://www.imooc.com/article/20596?block_id=tuijian_wz</a><br>来源：慕课网</p>
<h6 id="Constructor-默认存在-：类的构造函数"><a href="#Constructor-默认存在-：类的构造函数" class="headerlink" title="Constructor(默认存在)：类的构造函数"></a>Constructor(默认存在)：类的构造函数</h6></li>
</ol>
<p>1.在使用new命令创建对象实例时，自动调用该方法，没有显示定义也会有一个默认的该方法添加，座椅每个类必须有一个该方法，<br>2.一般情况下该方法会返回实例对象this，但是也可以指定constructor方法返回全新的对象</p>
<p>==那么对于私有的方法和属性的标准是什么呢，需要满足一下要求==</p>
<ol>
<li>class内部不同方法间可以使用，因此this要指向实例化对象（必须）</li>
<li>不能被外部访问，因此实例化对象person.name既不能获得值，也不能设定值，应该返回undefined，甚至应该在实例化之后，并不知道有name这个属性存在，（必须）</li>
<li>不能被继承，因此extends后子类不具备该属性（必须）</li>
</ol>
<h5 id="Super关键字："><a href="#Super关键字：" class="headerlink" title="Super关键字："></a>Super关键字：</h5><p>Super关键字既可以当做函数只用，可以当做对象使用，在使用方法上不同时，同发会完全不同。</p>
<h6 id="1-Super虽然是代表父类的构造函数，但是在进行返回时，则是返回子类的构造函数"><a href="#1-Super虽然是代表父类的构造函数，但是在进行返回时，则是返回子类的构造函数" class="headerlink" title="1. Super虽然是代表父类的构造函数，但是在进行返回时，则是返回子类的构造函数"></a>1. Super虽然是代表父类的构造函数，但是在进行返回时，则是返回子类的构造函数</h6><h6 id="2-super在子类中一般有三种作用"><a href="#2-super在子类中一般有三种作用" class="headerlink" title="2. super在子类中一般有三种作用"></a>2. super在子类中一般有三种作用</h6><ol>
<li><p>作为父类的构造函数调用</p>
</li>
<li><p>在普通方法中，作为父类的实例调用</p>
</li>
<li><p>在静态方法中，作为父类调用</p>
<h5 id="Const创建对象："><a href="#Const创建对象：" class="headerlink" title="Const创建对象："></a>Const创建对象：</h5></li>
<li><p>Const定义的对象属性是可以改变的，但是const定义的基本数据类型不的变量不能修改</p>
</li>
<li><p>const 指针指向的地址不可以变化，指向地址的内容可以变化。</p>
</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag"># js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/12/js事件委托，git和gvm/" rel="prev" title="js事件委托，git和gvm">
                js事件委托，git和gvm <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">任巧巧</p>
              <p class="site-description motion-element" itemprop="description">记录自己的学习之路</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/hexo/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/renfeiyan" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/e0a3702cacb5" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#js对象创建"><span class="nav-number">1.</span> <span class="nav-text">js对象创建</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#对象的组成"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">对象的组成</span></a></li></ol></li></ol><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Object实例"><span class="nav-number">1.1.</span> <span class="nav-text">1.Object实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-工厂模式"><span class="nav-number">1.2.</span> <span class="nav-text">2.工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-构造函数模式（new-一个新对象）"><span class="nav-number">1.3.</span> <span class="nav-text">3.构造函数模式（new 一个新对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-原型模式"><span class="nav-number">1.4.</span> <span class="nav-text">4.原型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-组合使用构造函数模式和原型模式"><span class="nav-number">1.5.</span> <span class="nav-text">5.组合使用构造函数模式和原型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-动态原型模式（不是很明白）"><span class="nav-number">1.6.</span> <span class="nav-text">6.动态原型模式（不是很明白）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承："><span class="nav-number">1.7.</span> <span class="nav-text">继承：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链"><span class="nav-number">1.8.</span> <span class="nav-text">原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#buchong"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">buchong</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructor："><span class="nav-number">1.9.</span> <span class="nav-text">Constructor：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this"><span class="nav-number">1.10.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">1.11.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-原型链继承"><span class="nav-number">1.11.1.</span> <span class="nav-text">1.原型链继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-直接继承prototype"><span class="nav-number">1.11.2.</span> <span class="nav-text">2. 直接继承prototype</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-寄生式继承："><span class="nav-number">1.11.3.</span> <span class="nav-text">3. 寄生式继承：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#借用构造函数继承"><span class="nav-number">1.11.4.</span> <span class="nav-text">借用构造函数继承</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#原型链-构造函数继承（组合继承-伪经典继承）-发挥二者之"><span class="nav-number">1.11.4.1.</span> <span class="nav-text">原型链+构造函数继承（组合继承/伪经典继承）:发挥二者之</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Object-create-方法"><span class="nav-number">1.11.5.</span> <span class="nav-text">5.Object.create()方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-defineProperty的作用"><span class="nav-number">1.11.6.</span> <span class="nav-text">Object.defineProperty的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#getter-and-setter"><span class="nav-number">1.11.6.1.</span> <span class="nav-text">getter and setter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#es6-class"><span class="nav-number">1.12.</span> <span class="nav-text">es6 class</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Constructor-默认存在-：类的构造函数"><span class="nav-number">1.12.0.1.</span> <span class="nav-text">Constructor(默认存在)：类的构造函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Super关键字："><span class="nav-number">1.12.1.</span> <span class="nav-text">Super关键字：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Super虽然是代表父类的构造函数，但是在进行返回时，则是返回子类的构造函数"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">1. Super虽然是代表父类的构造函数，但是在进行返回时，则是返回子类的构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-super在子类中一般有三种作用"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">2. super在子类中一般有三种作用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Const创建对象："><span class="nav-number">1.12.2.</span> <span class="nav-text">Const创建对象：</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">任巧巧</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
